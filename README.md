# JAVA_Study_Route
个人java学习路线，参照阿里P7学习路线

# 基础篇

1、JVM内存结构

堆是先进先出，线程共有，用来存放new出来的对象与数组，通过设置-Xss避免java.lang.StackOverflowError；栈是先进后出，线程私有，用来存放基本数据类型变量和对象的引用变量地址；方法区用来存放方法和static变量

直接内存又称堆外内存，是JDK1.4之后新增NIO类，通过Native函数库直接分配的堆外内存，直接内存受本机内存大小限制，IO读写性能优于堆内存

2、JVM内存模型

工作内存与主内存，主内存存储共享变量，每个线程都有各自独立的工作内存，线程与线程之间是相关隔离的。内存模型工作场景：线程A操作共享变量;复制变量副本同步到主内存;线程B从主内存将共享变量副本同步回自己的工作内存，这里在在线程B同步变量之前会出现共享变量已改变却无法得知，即存在内存不可见性问题，使用volatile关键词来定义共享变量来保证内存可见性，其原理在于每次访问变量都会刷新，即每次访问实时的

重排序：之所以重排序是当一个变量被其他线程占用时优先进行其余变量的操作，提升访问JVM性能，但是在多线程情况下，重排序会对逻辑判断带来影响，使用volatile关键字解决，Volatile关键字能确保变量在线程中的操作不会被重排序而是按照代码中规定的顺序进行访问

并发编程的三个概念：
  
  原子性：即一个操作或者多个操作全部执行且执行过程不被任何因素打断，要么都不执行
  
  可见性：当多个线程访问同一个变量时，一个线程修改了该变量的值，其他线程能够立即看到变量修改值
  
  有序性：即程序执行的顺序按照代码先后顺序执行
  
  final修饰类不可继承，修饰方法不能重写，修饰变量不可更改
  
  static修饰内部类、方法、代码段、变量，强调只有一个值可修改

3　垃圾回收
  
  内存分配策略：新生代、老年代、持久代（JAVA8已删除，改用本地内存存储类元数据）
    
    1、对象优先在Eden区分配，Eden：Survivor0:Survivor1=8:1:1,每次使用Eden与Survivor0，当两者内存都满时，会将依然存活的对象一次性复制到Survivor1，然后清空Eden和Survivor0，然后Survivor0再与Survivor1交换，当Eden区不足时，会触发Minor GC；
    
    2、长期存活的对象在老年代分配，每次MinorGC进入Survivor0区存活年龄加1，默认大于等于15后进入老年代（ "-XX:MaxTenuringThreshold"：15），此外JVM可动态根据Survivor空间相同年龄对象大小大于Survivor空间的一般，可直接晋级老年代，即动态对象年龄判定
   
   垃圾收集器发展是：串行（Serial）收集器--->单线程回收、并行（Parallel）收集器--->多线程回收、并发（CMS）收集器--->多线程回收且FUll GC时不暂停应用进程、G1收集器--->降低内存碎片的产生率
   
   G1收集器：取消新生代、老年代的概念，堆内存中一部分属于新生代、一部分属于老年代，G1将对象从一个区域复制到另一个区域，完成清理工作，同时进行部分堆的压缩，避免cms内存碎片问题存在（内存碎片可理解不连续内存）
   
   GC回收算法：
    
    引用计数算法（Reference Counting）：新建对象的引用计数设为1，每次其引用赋值不同变量计数1，反之则减1，当引用计数为0满足回收条件
    
    复制算法（Copying）：分两块同样大小的内存，存活对象复制到一个区域，另一个区域进行一次性清除
    
    标记-清除算法（Mark-Sweep）：标记阶段，遍历引用树；回收阶段，清除未标记的对象，此算法需要暂停整个应用
    
    标记-整理算法：结合Mark-Sweep和Copying算法，存活对象按顺序排放
    
    分代收集算法：新生代采用copying算法，老年代采用mMrk-Sweep+Copying算法
    
   与G1回收期相关的参数
   
    -XX:+UseG1GC:使用G1回收器
    
    -XX:MaxGCPauseMillis:设置最大垃圾收集停顿时间
    
    -XX:GCPauseIntervalMillis:设置停顿间隔时间
    
    
